using System;
using System.IO;
using ZopfliSharp.Internal;


namespace ZopfliSharp
{
    /// <summary>
    /// Provides methods and properties used to compressing data.
    /// </summary>
    public class ZopfliStream : ZopfliBaseStream
    {
        /// <summary>
        /// Cache of CRC-32 table. This table is generated by <see cref="GenerateCrc32Table"/>.
        /// </summary>
        private static uint[] _crc32Table;

        /// <summary>
        /// Options for Zopfli compression.
        /// </summary>
        /// <seealso cref="Zopfli.Compress(byte[], in ZopfliOptions)"/>
        /// <seealso cref="Zopfli.Compress(byte[], in ZopfliOptions, ZopfliFormat)"/>
        /// <seealso cref="Zopfli.Compress(byte[], int, int, in ZopfliOptions)"/>
        /// <seealso cref="Zopfli.Compress(byte[], int, int, in ZopfliOptions, ZopfliFormat)"/>
        public ZopfliOptions Options { get; set; }
        /// <summary>
        /// Output binary format.
        /// </summary>
        public ZopfliFormat Format { get; }

        /// <summary>
        /// Check sum value of CRC-32 or adler32.
        /// </summary>
        private uint _checksum;
        /// <summary>
        /// A flag whether Write was called first or not.
        /// </summary>
        private bool _isFirstWrite = true;
        /// <summary>
        /// <para>Total amount of input data size.</para>
        /// <para>This value is only used for GZip footer.</para>
        /// </summary>
        private uint _inflatedSize = 0;
        /// <summary>
        /// Bit pointer value.
        /// </summary>
        private byte _bitPointer = 0;

        /// <summary>
        /// Initializes a new instance of the <see cref="ZopfliStream"/> class
        /// by using the specified stream.
        /// </summary>
        /// <param name="stream">Destination stream</param>
        /// <param name="leaveOpen">true to leave the stream object open after disposing
        /// the <see cref="ZopfliStream"/> object; otherwise, false.</param>
        public ZopfliStream(Stream stream, bool leaveOpen = true)
            : this(stream, ZopfliOptions.GetDefault(), leaveOpen)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ZopfliStream"/> class
        /// by using the specified stream and options.
        /// </summary>
        /// <param name="stream">Destination stream</param>
        /// <param name="options">Options for Zopfli compression.</param>
        /// <param name="leaveOpen">true to leave the stream object open after disposing
        /// the <see cref="ZopfliStream"/> object; otherwise, false.</param>
        public ZopfliStream(Stream stream, in ZopfliOptions options, bool leaveOpen = true)
            : this(stream, options, ZopfliFormat.GZip, leaveOpen)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ZopfliStream"/> class
        /// by using the specified stream, options and binary format.
        /// </summary>
        /// <param name="stream">Destination stream</param>
        /// <param name="options">Options for Zopfli compression.</param>
        /// <param name="format">Output binary format.</param>
        /// <param name="leaveOpen">true to leave the stream object open after disposing
        /// the <see cref="ZopfliStream"/> object; otherwise, false.</param>
        public ZopfliStream(Stream stream, in ZopfliOptions options, ZopfliFormat format, bool leaveOpen = true)
            : base(stream, leaveOpen)
        {
            Options = options;
            Format = format;
        }


        /// <summary>
        /// writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the current stream.</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            var format = Format;
            if (_isFirstWrite)
            {
                if (format == ZopfliFormat.GZip)
                {
                    WriteGzipHeader(BaseStream);
                    _checksum = 0xffffffff;
                }
                else if (format == ZopfliFormat.ZLib)
                {
                    WriteZlibHeader(BaseStream);
                    _checksum = 0x00000001;
                }
                _isFirstWrite = false;
            }

            if (format == ZopfliFormat.GZip)
            {
                _checksum = UpdateCrc32(buffer, offset, count, _checksum);
            }
            else if (format == ZopfliFormat.ZLib)
            {
                _checksum = UpdateAdler32(buffer, offset, count, _checksum);
            }

            var deflatedSize = UIntPtr.Zero;
            Zopfli.ZopfliDeflate(
                buffer,
                offset,
                count,
                true,
                Options,
                ref _bitPointer,
                out MallocedMemoryHandle deflatedData,
                ref deflatedSize);

            using (deflatedData)
            {
                WriteData(BaseStream, deflatedData, deflatedSize);
            }
            _inflatedSize += (uint)count;
        }

        /// <summary>
        /// Write footer if needed and flush data.
        /// </summary>
        public override void Flush()
        {
            base.Flush();

            if (Format == ZopfliFormat.GZip)
            {
                WriteGzipFooter(BaseStream, _inflatedSize, FinalizeCrc32(_checksum));
            }
            else if (Format == ZopfliFormat.ZLib)
            {
                WriteZlibFooter(BaseStream, _checksum);
            }
            BaseStream.Flush();
        }

        /// <summary>
        /// Write header of zlib format.
        /// </summary>
        /// <param name="s">Destination stream.</param>
        private static void WriteZlibHeader(Stream s)
        {
            const uint cmf = 120;  /* CM 8, CINFO 7. See zlib spec.*/
            const uint flevel = 3;
            const uint fdict = 0;

            uint cmfflg = 256 * cmf + fdict * 32 + flevel * 64;
            uint fcheck = 31 - cmfflg % 31;
            cmfflg += fcheck;

            s.WriteByte((byte)(cmfflg / 256));
            s.WriteByte((byte)(cmfflg % 256));
        }

        /// <summary>
        /// Write footer of zlib format, just writing value of Adler-32.
        /// </summary>
        /// <param name="s">Destination stream.</param>
        /// <param name="adler32">Checksum value of Adler-32.</param>
        private static void WriteZlibFooter(Stream s, uint adler32)
        {
            s.WriteByte((byte)((adler32 >> 24) & 0xff));
            s.WriteByte((byte)((adler32 >> 16) & 0xff));
            s.WriteByte((byte)((adler32 >> 8) & 0xff));
            s.WriteByte((byte)(adler32 & 0xff));
        }

        /// <summary>
        /// Write header of gzip format.
        /// </summary>
        /// <param name="s">Destination stream.</param>
        private static void WriteGzipHeader(Stream s)
        {
            var gzipHeader = new byte[] {
                31,  // ID1
                139,  // ID2
                8, // CM
                0,  // FLG
                0, 0, 0, 0,  // MTIME
                2,  // XFL, 2 indicates best compression.
                3  // OS follows Unix conventions.
            };
            s.Write(gzipHeader, 0, gzipHeader.Length);
        }

        /// <summary>
        /// Write footer of gzip format, just writing value of CRC-32 and inflated data size.
        /// </summary>
        /// <param name="s">Destination stream.</param>
        /// <param name="inflatedSize"></param>
        /// <param name="crc32">Checksum value of Adler-32.</param>
        private static void WriteGzipFooter(Stream s, uint inflatedSize, uint crc32)
        {
            // CRC-32
            s.WriteByte((byte)(crc32 & 0xff));
            s.WriteByte((byte)((crc32 >> 8) & 0xff));
            s.WriteByte((byte)((crc32 >> 16) & 0xff));
            s.WriteByte((byte)((crc32 >> 24) & 0xff));

            // ISIZE
            s.WriteByte((byte)(inflatedSize & 0xff));
            s.WriteByte((byte)((inflatedSize >> 8) & 0xff));
            s.WriteByte((byte)((inflatedSize >> 16) & 0xff));
            s.WriteByte((byte)((inflatedSize >> 24) & 0xff));
        }

        /// <summary>
        /// Write deflated data to <paramref name="s"/>.
        /// </summary>
        /// <param name="s">Destination stream.</param>
        /// <param name="handle">Memory handle returned from <see cref="Zopfli.ZopfliDeflate(byte[], int, int, bool, in ZopfliOptions, ref byte, out MallocedMemoryHandle, ref UIntPtr)"/>.</param>
        /// <param name="size">Data size of <paramref name="handle"/>.</param>
        private static unsafe void WriteData(Stream s, MallocedMemoryHandle handle, UIntPtr size)
        {
            using (var ums = new UnmanagedMemoryStream((byte*)handle.DangerousGetHandle(), (long)size))
            {
                ums.CopyTo(s);
            }
        }

        /// <summary>
        /// Update intermediate CRC-32 value.
        /// </summary>
        /// <param name="data"><see cref="byte"/> data array.</param>
        /// <param name="offset">Offset of <paramref name="data"/>.</param>
        /// <param name="count">Data count of <paramref name="data"/>.</param>
        /// <param name="crc32">Intermidiate CRC-32 value.</param>
        /// <returns>Updated intermidiate CRC-32 value.</returns>
        private static uint UpdateCrc32(byte[] data, int offset, int count, uint crc32 = 0xffffffff)
        {
            var crc32Table = GetCrc32Table();

            var c = crc32;
            for (int i = offset, n = offset + count; i < n; i++)
            {
                c = crc32Table[(c ^ data[i]) & 0xff] ^ (c >> 8);
            }

            return c;
        }

        /// <summary>
        /// Calculate CRC-32 value from intermidiate CRC-32 value.
        /// </summary>
        /// <param name="crc32">Intermidiate CRC-32 value</param>
        /// <returns>CRC-32 value.</returns>
        private static uint FinalizeCrc32(uint crc32)
        {
            return crc32 ^ 0xffffffff;
        }

        /// <summary>
        /// <para>Get CRC-32 table cache.</para>
        /// <para>If the cache is not generated, generate and return it.</para>
        /// </summary>
        /// <returns>CRC-32 table</returns>
        private static uint[] GetCrc32Table()
        {
            if (_crc32Table == null)
            {
                _crc32Table = GenerateCrc32Table();
            }
            return _crc32Table;
        }

        /// <summary>
        /// Generate CRC-32 value.
        /// This method only used in <see cref="GenerateCrc32Table"/>.
        /// </summary>
        /// <returns>CRC-32 table.</returns>
        private static uint[] GenerateCrc32Table()
        {
            var crcTable = new uint[256];

            for (int n = 0; n < crcTable.Length; n++)
            {
                var c = (uint)n;
                for (var k = 0; k < 8; k++)
                {
                    c = (c & 1) != 0 ? (0xedb88320 ^ (c >> 1)) : (c >> 1);
                }
                crcTable[n] = c;
            }

            return crcTable;
        }

        /// <summary>
        /// Update intermediate CRC-32 value.
        /// </summary>
        /// <param name="data"><see cref="byte"/> data array.</param>
        /// <param name="offset">Offset of <paramref name="data"/>.</param>
        /// <param name="count">Data count of <paramref name="data"/>.</param>
        /// <param name="adler32">Adler-32 value.</param>
        /// <returns>Updated Adler-32 value.</returns>
        private static uint UpdateAdler32(byte[] data, int offset, int count, uint adler32 = 0x00000001)
        {
            const int sumsOverflow = 5550;

            var s1 = (adler32 & 0xffff);
            var s2 = (adler32 >> 16) & 0xffff;

            while (count > 0) {
                int amount = count > sumsOverflow ? sumsOverflow : count;
                count -= amount;
                while (amount > 0) {
                    s1 += data[offset];
                    s2 += s1;
                    amount--;
                    offset++;
                }
                s1 %= 65521;
                s2 %= 65521;
            }

            return (s2 << 16) | s1;
        }
    }
}
